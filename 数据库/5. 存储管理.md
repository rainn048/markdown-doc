# 存储管理

在今天的商业应用中，主要有两种基本类型的 DBMS（数据库管理系统）存储管理器：

1. DBMS 直接与底层的面向磁盘的块模式设备驱动程序进行交互（通常称为原始模式访问）；
2. DBMS 使用标准的 OS 文件系统设施。
不同的类型会在空间和时间上同时影响 DBMS控制存储的能力。

## 空间控制

从磁盘中读取和写入数据时，顺序读写要比随机读写快 10 到 100 倍。 对于 DBMS 存储管理器来说，如何把数据块放置在磁盘上就显得尤其重要， 从而使得需要访问大量数据的查询可以顺序地访问磁盘。 因为 DBMS 能够比底层操作系统更理解它的工作负载访问模式， 所以， 完全由 DBMS 设计师来确定如何把数据库块放置到磁盘上，是有意义的。

1. 直接存储到“原始”磁盘设备中，收益越来越小，已经不再推荐。
2. 在操作系统的文件管理系统中创建一个非常大的文件， 然后采用数据在文件中的地址偏移量来定位数据。

## 时间控制:缓冲

DBMS 还必须控制数据什么时候被物理地写入到磁盘中。

大多数操作系统的文件系统还提供内置的 I / O 缓冲机制， 来决定何时读取和何时写入文件块。

如果 DBMS 在执行写操作时使用标准的文件系统接口，操作系统缓冲机制将会打乱 DBMS 逻辑程序的意图，因为， 操作系统缓冲机制会悄悄地推迟 DBMS 写操作或者重新排序写操作。这可能会给 DBMS 带来大问题：

1. 数据库的 ACID 事务承诺的正确性： 如果不能对磁盘写操作的时间和顺序进行显式的控制， 那么，在发生软件或硬件失败后， DBMS 不能保证原子恢复。 写前日志（write ahead logging）要求一个写操作在写入到数据库相应的设备之前，必须先写入日志设备， 在此之前，不能给用户返回提交请求。
2. 性能问题。 操作系统的文件系统， 通常提供了内置功能支持“预读取（read-ahead）”（随机的读取） 和“后写入（write-behind）” (延迟， 批处理)。这些对于 DBMS 访问模式而言，通常都不适合。 文件系统的逻辑程序，会根据文件中的物理字节偏移量连续性来做出提前读取的决定。 DBMS 级别的 I/O 设施，可以根据未来的读请求来做出逻辑预测 I/O 决定， 这些未来的读请求在 SQL查询处理层面是可以知道的，但是在文件系统层面上则很难做到。
3. “双缓冲” 和内存拷贝的昂贵的 CPU 开销。 鉴于 DBMS 必须妥善管理自己的缓冲从而保证正确性，因此， 任何由操作系统提供的额外缓冲都是多余的。这种冗余会引起两个代价。第一， 它浪费了系统内存，因为它显著地减少了系统中可用于有用工作的内存。第二， 它浪费了时间和处理资源，因为它会导致额外的复制步骤：执行读取操作时，数据会首先从磁盘复制到操作系统的缓冲区， 然后再复制到 DBMS 缓冲池。而写数据时，这两者都刚好相反，即先把数据写入到 DBMS 缓冲池，然后再复制到操作系统的缓冲区，最后写入磁盘。

## 缓冲管理

为了提供对数据库页面的有效访问，每个数据库管理系统会在自己的内存空间中实现一个大型共享缓冲池。

缓冲池会被组织成一个帧数组，其中， 每一帧是内存中的一段区域，帧的大小是数据库磁盘块的大小。块从磁盘直接复制到缓冲池中，不会发生格式的变化， 在内存中也是以这种原生的格式进行修改操作，然后，写回磁盘。 这种不需要转换的方法， 避免了在向磁盘写入数据和从磁盘读取数据过程中的CPU 瓶颈。也许更为重要的是，固定大小的帧，避免了通用技术导致的外部碎片和压缩方面的内存管理复杂性。
