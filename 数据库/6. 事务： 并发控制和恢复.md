# 事务：并发控制和恢复

数据库系统真正庞大而复杂的部分是事务存储管理器，该部分由四个彼此紧密关联的组件组成：

* 用于并发控制的锁管理器；
* 用于事务恢复的日志管理器；
* 数据库 I/O 缓冲池；
* 用于组织磁盘数据的访问方法。

ACID 表示事务的原子性、一致性、独立性和持久性。但是，它们并不是为保证事务正确而被正式定义并经得起数学论证的术语。尽管 ACID 并不是正式术语，但是，它对于我们组织讨论事务系统是很有用的，而且，它非常重要，因此，我们在这里再回顾一下：

* 原子性：是对事务“全部做或者全部不做”的保证——即事务的所有行为或者全部提交或者全部不做；
* 一致性：是应用层面的一个保证； SQL 语句的完整性约束通常就是用于在数据库系统中保证一致性的。给定一个由约束条件集提供的一致性定义，只有当一个事务在完成时可以使得整个数据库仍保持一致性状态的时候，这个事务才能被提交；
* 隔离性：使得对于应用开发者而言，两个并发的事务看不到彼此正在进行的更新操作。这样，应用开发者就不必因担心其他事务的脏数据而采取防御性编程，可以当做只有自己在访问数据库；
* 持久性：是指保证一个成功提交的事务对数据库的更新是永久的，即便之后发生软件或者硬件故障，除非另一个提交的事务将它重写。

简单地说，现代数据库管理系统通过锁协议来实现隔离性。持久性通过日志和恢复技术来实现。隔离性和原子性由锁（使瞬时数据库状态不可见）和日志（确保可见数据的正确性）来保证。一致性由查询处理器运行时的检查来管理：如果一个事务违反一个 SQL 一致性约束，这个事务就会被终止，并且返回错误信息。

可串行化是并发事务正确性的一个很好的书面定义。 可串行化是由 DBMS 并发控制模型来实现的。这里有三种并发控制的技术，它们在教材和早期的文件中都有详细描述，这里我们再简短回顾一下：

* 严格的两段锁（2PL）：事务在读任何数据之前需要一个共享锁，而在写之前需要一个排他锁。 一个事务所拥有的锁，会一直保持到事务结束时才自动释放。当一个事 务等待锁时，会中断然后移动到等待队
* 多版本并发控制（MVCC）：事务不使用锁控制机制，我们为过去某一时间点的数据库状态保存一个一致的副本，即便在某一固定时间点之后数据库状态发生了改变，我们也可以读到数据库的一个过去的状态。
* 乐观并发控制（OCC）：该方法允许多个事务在无阻塞的情况下读或者更新一个数据项。事务会保存自身的读写历史，在一个事务提交前，必须通过检查其读写历史来判断是否发生了隔离性冲突；若发生，则发生冲突的其中一个事务必须回滚。
