# 闭包

一般情况下，函数里的本地变量只能在函数内部访问，函数退出之后，作用域就没用了，它对应的栈桢被弹出，作用域中的所有变量所占用的内存也会被收回。

但是闭包（Closure）却不同。

在 JavaScript 中，用外层函数返回一个内层函数之后，这个内层函数能一直访问外层函数中的本地变量。按理说，这个时候外层函数已经退出了，它里面的变量也该作废了。可闭包却非常执着，即使外层函数已经退出，但内层函数仿佛不知道这个事实一样，还继续访问外层函数中声明的变量，并且还真的能够正常访问。

本节解决两个问题：

* 函数要变成一等公民。也就是要能把函数像普通数值一样赋值给变量，可以作为参数传递给其他函数，可以作为函数的返回值。
* 要让内层函数一直访问它环境中的变量，不管外层函数退出与否。

```js
/**
 * clojure.js
 * 测试闭包特性
 * 作者：宫文学
 */
var a = 0;
var fun1 = function(){
    var b = 0;                // 函数内的局部变量
    var inner = function(){   // 内部的一个函数
        a = a+1;
        b = b+1;
        return b;             // 返回内部的成员
    }
    return inner;             // 返回一个函数
}
console.log("outside:  a=%d", a);
var fun2 = fun1();                            // 生成闭包
for (var i = 0; i< 2; i++){
    console.log("fun2: b=%d a=%d",fun2(), a); //通过fun2()来访问b
}
var fun3 = fun1();                            // 生成第二个闭包
for (var i = 0; i< 2; i++){
    console.log("fun3: b=%d a=%d",fun3(), a); // b等于1，重新开始
}
 
 
// 结果
outside:  a=0
fun2: b=1 a=1
fun2: b=2 a=2
fun3: b=1 a=3
fun3: b=2 a=4
```

观察这个结果，可以得出两点：

* 内层的函数能访问它“看得见”的变量，包括自己的本地变量、外层函数的变量 b 和全局变量 a。
* 内层函数作为返回值赋值给其他变量以后，外层函数就结束了，但内层函数仍能访问原来外层函数的变量 b，也能访问全局变量 a。

这样似乎让人感到困惑：站在外层函数的角度看，明明这个函数已经退出了，变量 b 应该失效了，为什么还可以继续访问？但是如果换个立场，站在 inner 这个函数的角度来看，声明 inner 函数的时候，告诉它可以访问 b，不能因为把 inner 函数赋值给了其他变量，inner 函数里原本正确的语句就不能用了啊。

其实，只要函数能作为值传来传去，就一定会产生作用域不匹配的情况，这样的内在矛盾是语言设计时就决定了的。我认为，闭包是为了让函数能够在这种情况下继续运行所提供的一个方案。这个方案有一些不错的特点，比如隐藏函数所使用的数据，歪打正着反倒成了一个优点了！

静态作用域（Static Scope）：符号之间的引用关系在编译期就确定了，在运行时不会变。大部分语言都是静态作用域。

动态作用域（Dynamic Scope）：变量引用跟变量声明不是在编译时就绑定死了的。在运行时，在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。

```js
// 静态作用域
int i = 1;
void foo(){
  println(i); // 访问全局变量
}
foo();        // 访问全局变量
void bar(){
  int i = 2;
  foo();      // 在这里调用foo()，访问的仍然是全局变量
}
```

## 函数作为一等公民

当函数可以像值一样传递、给变量赋值、作为参数传递给其他函数、作为函数返回值等等，这时候我们就说函数是一等公民。

函数作为基础类型，就可以用函数来声明变量了。

首先需要定义语法规则，增加一个函数声明的解析规则。

## 闭包的实现

1. 当函数作为返回值返回给调用者时，这时函数还能访问外层作用域，这时候就需要把用的环境变量打包，创建一个新的对象，返回给调用者；
2. 调用者在使用这个函数时，在这个私有的闭包环境中可以访问外层作用域的变量，这就形成了闭包。
