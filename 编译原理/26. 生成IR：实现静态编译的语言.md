不过，如果我们要像前面生成汇编语言那样，通过字符串拼接来生成 LLVM 的 IR，除了要了解 LLVM IR 的很多细节之外，代码一定比较啰嗦和复杂，因为字符串拼接不是结构化的方法，所以，最好用一个定义良好的数据结构来表示 IR。

好在 LLVM 项目已经帮我们考虑到了这一点，它提供了代表 LLVM IR 的一组对象模型，我们只要生成这些对象，就相当于生成了 IR，这个难度就低多了。而且，LLVM 还提供了一个工具类，IRBuilder，我们可以利用它，进一步提升创建 LLVM IR 的对象模型的效率，让生成 IR 的过程变得更加简单！

## LLVM IR 的对象模型

LVM 在内部有用 C++ 实现的对象模型，能够完整表示 LLVM IR，当我们把字节码读入内存时，LLVM 就会在内存中构建出这个模型。只有基于这个对象模型，我们才可以做进一步的工作，包括代码优化，实现即时编译和运行，以及静态编译生成目标文件。所以说，这个对象模型是 LLVM 运行时的核心。
![](images/Dingtalk_20211216180133.jpg)

IR 对象模型的头文件在include/llvm/IR目录下，其中最重要的类包括：

* Module（模块）
  
    Module 类聚合了一个模块中的所有数据，它可以包含多个函数。你可以通过 Model::iterator 来遍历模块中所有的函数。它也包含了一个模块的全局变量。

* Function（函数）
  
  Function 包含了与函数定义（definition）或声明（declaration）有关的所有对象。函数定义包含了函数体，而函数声明，则仅仅包含了函数的原型，它是在其他模块中定义的，在本模块中使用。

* BasicBlock（基本块）
  
  BasicBlock 封装了一系列的 LLVM 指令，你可以借助 bigin()/end() 模式遍历这些指令，还可以通过 getTerminator() 方法获得最后一条指令（也就是终结指令）。你还可以用到几个辅助方法在 CFG 中导航，比如获得某个基本块的前序基本块。

* Instruction（指令）
  
  Instruction 类代表了 LLVM IR 的原子操作（也就是一条指令），你可以通过 getOpcode() 来获得它代表的操作码，它是一个 llvm::Instruction 枚举值，你可以通过 op_begin() 和 op_end() 方法对获得这个指令的操作数。

* Value（值）
  
  Value 类代表一个值。在 LLVM 的内存 IR 中，如果一个类是从 Value 继承的，意味着它定义了一个值，其他方可以去使用。函数、基本块和指令都继承了 Value。

* LLVMContext（上下文）
  
  这个类代表了 LLVM 做编译工作时的一个上下文，包含了编译工作中的一些全局数据，比如各个模块用到的常量和类型。
